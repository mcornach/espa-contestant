'''Utility functions to support the make_offer.py code'''import numpy as npimport osimport jsonimport pandas as pdimport datetimeclass NpEncoder(json.JSONEncoder):    def default(self, obj):        if isinstance(obj, np.integer):            return int(obj)        if isinstance(obj, np.floating):            return float(obj)        if isinstance(obj, np.ndarray):            return obj.tolist()        return json.JSONEncoder.default(self, obj)parameter_domains = {}parameter_domains['cost_rgu'] = ['resource', 't']parameter_domains['cost_rgd'] = ['resource', 't']parameter_domains['cost_spr'] = ['resource', 't']parameter_domains['cost_nsp'] = ['resource', 't']parameter_domains['init_en'] = ['resource']parameter_domains['init_status'] = ['resource']parameter_domains['ramp_dn'] = ['resource']parameter_domains['ramp_up'] = ['resource']parameter_domains['chmax'] = ['resource', 't']parameter_domains['dcmax'] = ['resource', 't']parameter_domains['socmax'] = ['resource']parameter_domains['socmin'] = ['resource']parameter_domains['block_ch_mc'] = ['resource', 'offer_block', 't']parameter_domains['block_dc_mc'] = ['resource', 'offer_block', 't']parameter_domains['block_soc_mc'] = ['resource', 'offer_block', 't']parameter_domains['block_ch_mq'] = ['resource', 'offer_block', 't']parameter_domains['block_dc_mq'] = ['resource', 'offer_block', 't']parameter_domains['block_soc_mq'] = ['resource', 'offer_block', 't']parameter_domains['soc_end'] = ['resource']parameter_domains['soc_begin'] = ['resource']parameter_domains['eff_ch'] = ['resource']parameter_domains['eff_dc'] = ['resource']def load_json(filename, filedir='./'):    '''Find the status of your resources and of the next market configuration'''    with open(os.path.join(filedir,f'{filename}.json'), 'r') as f:        json_dict = json.load(f)    return json_dictdef split_mktid(mktid):    """Splits the market_id string into the market type and the time string (YYYYmmddHHMM)"""        split_idx = [i for i, char in enumerate(mktid) if char == '2'][0]    mkt_type = mktid[:split_idx]    start_time = mktid[split_idx:]    return mkt_type, start_timedef get_timeseries(status):    """Takes the starting time and market config to build the time series"""    mkt_type, start_time = split_mktid(status['market_id'])    mkt_spec = load_json('market_specification', '../')     for key, items in mkt_spec.items():        if mkt_type in items.keys():            durations = mkt_spec[key][mkt_type]['interval_durations']    d0, d1 = durations[0][0], durations[0][1]    times = np.zeros(d0, dtype=datetime.datetime)    times[0] = datetime.datetime.strptime(start_time, '%Y%m%d%H%M')    for i in range(1,d0):        times[i] = times[i-1] + datetime.timedelta(minutes = d1)    return timesdef get_latest_forecast(times, ftype, check_time=True):    """Loads either renewables or demand forecast"""    if ftype == 'demand':        df = pd.read_csv('../demand_forecast.csv')        df_times = pd.to_datetime(df['Time'].values.flatten())        power = df['MW'].values.flatten()    elif ftype == 'renewables':        dfw = pd.read_csv('../wind_forecast.csv')        dfs = pd.read_csv('../solar_forecast.csv')        df_times = pd.to_datetime(dfw['Time'].values.flatten())        powerw = dfw['MW'].values.flatten()        powers = dfs['MW'].values.flatten()        power = powerw+powers    # Now check for the proper time subset (may be unnecessary if we update forecast data with    # the market timestamps)    if check_time:        ind_arr = np.zeros(len(times), dtype=int)        for i in range(len(ind_arr)):            ind_arr[i] = np.where(df_times == times[i])[0][0]        power = power[ind_arr]    return powerdef fill_offer(key, value, timeseries):    # TODO - might change the line below to allow skipping of extra keys instead of exiting    assert key in parameter_domains.keys(), AssertionError(f"Key {key} not found in parameter_domains keys.")    value_array = (type(value) == np.ndarray)    if value is None:        return None    elif parameter_domains[key] == ['resource']:        return {'domain': parameter_domains[key],                'values': value,                }    elif parameter_domains[key] == ['resource', 't']:        if value_array:            return {'domain': parameter_domains[key],                    'keys': [t for t in timeseries],                    'values': [value[idx] for idx, t in enumerate(timeseries)],                    }        else:            return {'domain': parameter_domains[key],                    'keys': [t for t in timeseries],                    'values': [value for t in timeseries],                    }    elif parameter_domains[key] == ['resource', 'offer_block']:        if value_array:            value = list(value)        assert type(value) is list        return {'domain': parameter_domains[key],                'keys': [f'{b+1}' for b in range(len(value))],                'values': value                }    elif parameter_domains[key] == ['resource', 'offer_block', 't']:        if value_array:            return {'domain': parameter_domains[key],                    'keys': [(f"{b+1}", t) for b in range(value.shape[0]) for t in timeseries],                    'values': [value[b, idx] for b in range(value.shape[0])                                              for idx in range(len(timeseries))]                    }        else:            assert type(value) is list            return {'domain': parameter_domains[key],                    'keys': [(f"{b+1}", t) for b in range(len(value)) for t in timeseries],                    'values': [value[b] for b in range(len(value)) for t in timeseries]                    }    else:        raise ValueError(f"Format of key {key}:{parameter_domains[key]} is not supported.")    def offer_to_block(value, key):    ''' Takes a numpy array of costs and converts to a 2D offer block'''    # For now I'm splitting into two block offers, the second higher/lower depending on ch/dc    pcnt_change = 0.4    block1 = value    if 'dc' in key:        block2 = value*(1+pcnt_change)    else:        block2 = value*(1-pcnt_change)    block = np.vstack((block1, block2))    return blockdef compute_offers(rid, status, times, demand, renewables):    """Takes the status and forecast and makes an offer dictionary"""    rid_attributes = status['resources'][rid]    timestring = []    for time in times:        timestring += [time.strftime("%Y%m%d%H%M")]    sel_block = 'ch' # can select either 'ch' for ch/dc offers or 'soc' for soc offers    # Computes the ratio of renewables to demand - higher ratio means more renewables available    ratio_ren_dem = renewables/demand    median_ratio_rd = np.median(ratio_ren_dem)    ch_cost, ch_max = 20, 22    dc_cost, dc_min = 25, 23    soc_cost = 30    # We will loop through keys to fill our offer out, making updates as needed    resource_offer = {}    for key, offer in rid_attributes.items():        if key not in parameter_domains.keys():            continue        # Keep my default quantity parameters for now        if ('block' in key) and ('mq' in key):            try:                offer = [float(val.strip()) for val in offer.split(',')]            except AttributeError:                offer = [offer]        elif key == 'block_ch_mc':            offer = np.ones((1,len(times)))*ch_cost/median_ratio_rd*ratio_ren_dem*(sel_block=='ch')            offer[offer>ch_max] = ch_max            offer = offer_to_block(offer, key)        elif key == 'block_dc_mc':            offer = np.ones((1,len(times)))*dc_cost*median_ratio_rd/ratio_ren_dem*(sel_block=='ch')            offer[offer<dc_min] = dc_min            offer = offer_to_block(offer, key)        elif key == 'block_soc_mc':            offer = np.ones((1,len(times)))*soc_cost/median_ratio_rd*ratio_ren_dem*(sel_block!='ch')            offer = offer_to_block(offer, key)        resource_offer[key] = fill_offer(key=key, value=offer, timeseries=timestring)    attribute_offer = {"resource_name": rid, "participant_name": "p00001", "bus_location": 1,                       "resource_type": "str"}    offer_out = {"attributes": attribute_offer, "offer":resource_offer}    return offer_outdef save_offer(offer, rid, mktid):    """Saves the offer in json format to the correct resource directory"""    offer_dir = f'str_{rid}'    # Create the directory if it doesn't exist    if not os.path.exists(offer_dir):        os.makedirs(offer_dir)    # Write the data dictionary to a JSON file    json_file = os.path.join(offer_dir, f'{mktid}.json')    with open(json_file, "w") as f:        json.dump(offer, f, cls=NpEncoder, indent=4)